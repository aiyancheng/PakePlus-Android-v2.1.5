<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ°¸å·çˆ±çœ¼åŸç³é«˜æµ‹é‡å·¥å…·</title>
    <style>
        :root {
            --primary-color: #1677FF;
            --success-color: #7ed321;
            --warning-color: #f5a623;
            --danger-color: #e74c3c;
            --text-color: #2c3e50;
            --bg-color: #f8f9fa;
            --border-color: #e1e5eb;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
            --shadow-light: 0 2px 6px rgba(0,0,0,0.05);
            --radius: 8px;
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 10px;
            user-select: none;
            overflow-x: hidden;
            touch-action: manipulation;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header h1 {
            color: var(--primary-color);
            font-size: 1.8rem;
            margin-bottom: 8px;
        }
        
        .header p {
            color: #666;
            font-size: 1.1rem;
        }
        
        input[type="number"] {
            padding: 8px 10px;
            border: 2px solid var(--);
            border-radius: var(--radius);
            width: 100%;
            font-size: 0.9rem;
            -webkit-appearance: none;
            appearance: none;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-height: 36px;
        }
        
        button:hover, button:active {
            filter: brightness(0.9);
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .status-box {
            padding: 10px 12px;
            background: #f8f9fa;
            border-radius: var(--radius);
            border-left: 4px solid var(--);
            font-size: 0.9rem;
            min-height: 45px;
            display: flex;
            align-items: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .result-box {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .eye-result {
            padding: 20px;
            border-radius: var(--radius);
            text-align: center;
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
            box-shadow: var(--shadow-light);
            border: 1px solid var(--border-color);
        }
        
        .eye-result h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-size: 1.1rem;
        }
        
        .value {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-color);
        }
        
        .final-result {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, var(--), #3a7bc8);
            color: white;
            border-radius: var(--radius);
            text-align: center;
            font-size: 1.1rem;
        }
        
        .control-panel {
            background: #f8f9fa;
            padding: 12px;
            border-radius: var(--radius);
            margin: 15px 0;
            border-left: 4px solid var(--);
        }
        
        .control-row {
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: stretch;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        /* è°ƒæ•´å„ç»„çš„å®½åº¦æ¯”ä¾‹ */
        .control-group:nth-child(1) { /* æ“ä½œæ­¥éª¤ */
            flex: 4;
        }
        
        .control-group:nth-child(2) { /* ç¼©æ”¾æ§åˆ¶ */
            flex: 2;
        }
        
        .control-group:nth-child(3) { /* æ¯”ä¾‹è®¾å®š */
            flex: 3;
        }
        
        .control-group:nth-child(4) { /* æ’¤é”€æ“ä½œ */
            flex: 1;
        }
        
        .control-label {
            font-weight: bold;
            color: var(--primary-color);
            white-space: nowrap;
            font-size: 0.85rem;
            margin-bottom: 2px;
        }
        
        .control-content {
            flex: 1;
        }
        
        .zoom-section {
            display: flex;
            align-items: center;
            gap: 3px;
            background: white;
            padding: 3px;
            border-radius: var(--radius);
            justify-content: center;
            border: 1px solid var(--border-color);
            height: 45px;
        }
        
        .zoom-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition);
            min-height: auto;
        }
        
        .zoom-display {
            min-width: 50px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            padding: 0 3px;
        }
        
        canvas {
            border: 2px solid var(--border-color);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin: 15px auto;
            display: block;
            cursor: crosshair;
            max-width: 100%;
            max-height: 70vh;
            width: auto;
            height: auto;
            transition: var(--transition);
            touch-action: none;
        }
        
        .canvas-container {
            position: relative;
            margin: 20px 0;
            display: flex;
            justify-content: center;
        }
        
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: var(--radius);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
            box-shadow: var(--shadow);
        }
        
        .drag-hint, .precision-hint {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
        }
        
        .drag-hint {
            bottom: 10px;
            right: 10px;
        }
        
        .precision-hint {
            top: 10px;
            right: 10px;
        }
        
        .upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            border: 2px dashed var(--border-color);
            border-radius: var(--radius);
            background-color: #f8f9fa;
            margin: 20px 0;
            text-align: center;
            color: #666;
            transition: var(--transition);
            cursor: pointer;
            min-height: 200px;
        }
        
        .upload-area:hover, .upload-area:active {
            border-color: var(--primary-color);
            background-color: #eef7ff;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.6;
        }
        
        .upload-text {
            margin-top: 10px;
            font-size: 16px;
        }
        
        .instructions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: var(--radius);
            margin: 15px 0;
            font-size: 1rem;
        }
        
        .instructions h4 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        .instructions ol {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .calibration-input-group {
            display: flex;
            gap: 5px;
        }
        
        .calibration-input-group input {
            flex: 1;
        }
        
        .calibration-input-group button {
            flex: 0 0 auto;
            width: 90px;
        }
        
        .scale-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: white;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            margin-top: 6px;
        }
        
        .scale-label {
            font-weight: bold;
            color: var(--text-color);
            font-size: 0.85rem;
        }
        
        .scale-value {
            font-weight: bold;
            color: var(--primary-color);
            font-size: 0.85rem;
            white-space: nowrap;
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                max-width: 100%;
            }
            
            .header h1 {
                font-size: 1.4rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .control-row {
                flex-direction: column;
                gap: 12px;
            }
            
            .control-group {
                width: 100%;
            }
            
            .calibration-input-group {
                flex-direction: column;
            }
            
            .calibration-input-group button {
                width: 100%;
            }
            
            button {
                padding: 10px 12px;
                font-size: 0.9rem;
                min-height: 40px;
            }
            
            .zoom-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .zoom-display {
                min-width: 60px;
            }
            
            .value {
                font-size: 22px;
            }
            
            .status-box {
                font-size: 0.9rem;
                min-height: 50px;
            }
            
            canvas {
                max-height: 50vh;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.2rem;
            }
            
            button {
                padding: 8px 10px;
                font-size: 0.85rem;
                min-height: 36px;
            }
            
            .value {
                font-size: 20px;
            }
            
            .status-box {
                font-size: 0.85rem;
            }
        }
        
        /* éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† */
        .upload-hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ‘“ æ°¸å·çˆ±çœ¼åŸç³é«˜æµ‹é‡å·¥å…·</h1>
            <p>ç²¾ç¡®æµ‹é‡åŒçœ¼ç³é«˜ï¼Œä¸“ä¸šéªŒå…‰é…é•œè¾…åŠ©å·¥å…·</p>
        </div>
        
        <!-- ç»Ÿä¸€æ§åˆ¶é¢æ¿ - å•è¡Œå¸ƒå±€ -->
        <div class="control-panel">
            <div class="control-row">
                <!-- æ“ä½œæ­¥éª¤ -->
                <div class="control-group">
                    <div class="control-label">æ“ä½œæ­¥éª¤ï¼š</div>
                    <div class="control-content">
                        <div class="status-box" id="status">è¯·ä¸Šä¼ æ­£é¢çœ¼é•œä½©æˆ´ç…§ç‰‡</div>
                    </div>
                </div>
                
                <!-- ç¼©æ”¾æ§åˆ¶ -->
                <div class="control-group">
                    <div class="control-label">ç¼©æ”¾æ§åˆ¶ï¼š</div>
                    <div class="control-content">
                        <div class="zoom-section">
                            <button class="zoom-btn" id="zoomOut" title="ç¼©å°">-</button>
                            <div class="zoom-display" id="zoomLevel">100%</div>
                            <button class="zoom-btn" id="zoomIn" title="æ”¾å¤§">+</button>
                            <button class="zoom-btn" id="resetZoom" title="é‡ç½®ç¼©æ”¾">â†º</button>
                        </div>
                    </div>
                </div>
                
                <!-- æ¯”ä¾‹è®¾å®š -->
                <div class="control-group">
                    <div class="control-label">æ¯”ä¾‹è®¾å®šï¼š</div>
                    <div class="control-content">
                        <div class="calibration-input-group">
                            <input type="number" id="actualWidth" step="0.1" placeholder="é•œæ¡†å®½åº¦(mm)" min="0" max="200">
                            <button id="calculateScale">è®¡ç®—æ¯”ä¾‹</button>
                        </div>
                        <div class="scale-info">
                            <span class="scale-label">å½“å‰æ¯”ä¾‹ï¼š</span>
                            <span class="scale-value" id="scaleResult">0 mm/åƒç´ </span>
                        </div>
                    </div>
                </div>
                
                <!-- æ’¤é”€æ“ä½œ -->
                <div class="control-group">
                    <div class="control-label">æ’¤é”€æ“ä½œï¼š</div>
                    <div class="control-content">
                        <button id="undoButton" disabled title="æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ" style="height: 45px; width: 100%;">è¿”å›ä¸Šä¸€æ­¥</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä¸Šä¼ åŒºåŸŸ -->
        <div id="uploadArea" class="upload-area">
            <div class="upload-icon">ğŸ“·</div>
            <div style="margin-bottom: 15px;">ç‚¹å‡»æ‹ç…§æˆ–ä¸Šä¼ ç…§ç‰‡</div>
            <input type="file" id="imageUpload" accept="image/*" class="upload-hidden" capture="environment">
            <div class="upload-text">æ”¯æŒ JPGã€PNG æ ¼å¼ï¼Œæ¨èåˆ†è¾¨ç‡ 1920x1080 æˆ–æ›´é«˜</div>
        </div>
        
        <!-- ç”»å¸ƒå®¹å™¨ -->
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="canvas" style="display: none;"></canvas>
                <div class="drag-hint" id="dragHint" style="display: none;">æ‹–æ‹½å¯ç§»åŠ¨å›¾ç‰‡</div>
                <div class="precision-hint" id="precisionHint" style="display: none;">æ”¾å¤§åç‚¹å‡»æ›´ç²¾å‡†</div>
                <div class="canvas-overlay" id="canvasOverlay" style="display: none;">
                    <button id="reuploadButton">
                        ğŸ”„ é‡æ–°ä¸Šä¼ 
                    </button>
                </div>
            </div>
        </div>

        <!-- æµ‹é‡ç»“æœ -->
        <div id="measurementSection" style="display: none;">
            <h3 style="color: var(--primary-color); margin-top: 30px; margin-bottom: 15px;">ğŸ“ æµ‹é‡ç»“æœ</h3>
            <div class="result-box">
                <div class="eye-result" id="singleResult">
                    <h4>ç³é«˜æµ‹é‡ç»“æœ</h4>
                    <div class="value" id="singleValue">--</div>
                    <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">å³çœ¼ç³é«˜ | å·¦çœ¼ç³é«˜ | å·®å€¼</div>
                </div>
            </div>
            <div class="final-result" id="finalResult"></div>
        </div>

        <!-- ä½¿ç”¨è¯´æ˜ -->
        <div class="instructions">
            <h4>ğŸ“‹ ä½¿ç”¨è¯´æ˜</h4>
            <ol>
                <li><strong>ä¸Šä¼ ç…§ç‰‡ï¼š</strong>ç‚¹å‡»ä¸Šä¼ åŒºåŸŸæ‹ç…§æˆ–ä¸Šä¼ ä¸€å¼ æ¸…æ™°çš„æ­£é¢çœ¼é•œä½©æˆ´ç…§ç‰‡</li>
                <li><strong>æ ‡å®šæ¯”ä¾‹ï¼š</strong>å…ˆç‚¹å‡»é•œæ¡†å·¦è¾¹ç¼˜ï¼Œå†ç‚¹å‡»é•œæ¡†å³è¾¹ç¼˜ï¼Œç„¶åè¾“å…¥é•œæ¡†å®é™…å®½åº¦ï¼ˆæ¯«ç±³ï¼‰ï¼Œç‚¹å‡»"è®¡ç®—æ¯”ä¾‹"</li>
                <li><strong>æµ‹é‡ç³é«˜ï¼š</strong>ä¾æ¬¡ç‚¹å‡»å³çœ¼ç³å­”ä¸­å¿ƒã€å³çœ¼é•œæ¡†ä¸‹ç¼˜ã€å·¦çœ¼ç³å­”ä¸­å¿ƒã€å·¦çœ¼é•œæ¡†ä¸‹ç¼˜</li>
                <li><strong>æŸ¥çœ‹ç»“æœï¼š</strong>ç³»ç»Ÿä¼šè‡ªåŠ¨è®¡ç®—å¹¶æ˜¾ç¤ºåŒçœ¼ç³é«˜åŠå·®å€¼</li>
                <li><strong>æ“ä½œæŠ€å·§ï¼š</strong>ä½¿ç”¨ç¼©æ”¾æŒ‰é’®å¯æ”¾å¤§ç¼©å°å›¾ç‰‡ï¼Œæ”¾å¤§åç‚¹å‡»æ ‡è®°ç‚¹æ›´ç²¾å‡†ï¼›ç‚¹å‡»æ ‡è®°ç‚¹å¯æ‹–åŠ¨è°ƒæ•´ä½ç½®</li>
                <li><strong>æ³¨æ„äº‹é¡¹ï¼š</strong>ç¡®ä¿ç…§ç‰‡æ¸…æ™°ï¼Œçœ¼é•œä½©æˆ´ç«¯æ­£ï¼Œé¢éƒ¨æ­£å¯¹é•œå¤´ï¼Œé¿å…è§’åº¦å€¾æ–œå½±å“æµ‹é‡ç²¾åº¦</li>
            </ol>
        </div>
    </div>

<script>
// å…ƒç´ å¼•ç”¨
const Elements = {
    canvas: document.getElementById('canvas'),
    status: document.getElementById('status'),
    undoButton: document.getElementById('undoButton'),
    imageUpload: document.getElementById('imageUpload'),
    uploadArea: document.getElementById('uploadArea'),
    reuploadButton: document.getElementById('reuploadButton'),
    actualWidth: document.getElementById('actualWidth'),
    calculateScale: document.getElementById('calculateScale'),
    scaleResult: document.getElementById('scaleResult'),
    singleValue: document.getElementById('singleValue'),
    finalResult: document.getElementById('finalResult'),
    zoomIn: document.getElementById('zoomIn'),
    zoomOut: document.getElementById('zoomOut'),
    resetZoom: document.getElementById('resetZoom'),
    zoomLevel: document.getElementById('zoomLevel'),
    dragHint: document.getElementById('dragHint'),
    precisionHint: document.getElementById('precisionHint'),
    canvasOverlay: document.getElementById('canvasOverlay'),
    measurementSection: document.getElementById('measurementSection')
};

const ctx = Elements.canvas.getContext('2d');
const img = new Image();
let historyStack = [];
let currentState = {
    calibrationPoints: { left: null, right: null },
    measurementPoints: {
        right: { pupil: null, frameBottom: null },
        left: { pupil: null, frameBottom: null }
    },
    scale: 0,
    currentEye: 'right',
    selectedMarker: null
};

// ç¼©æ”¾ç›¸å…³å˜é‡
let zoom = 1.0;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let lastX, lastY;
let imageWidth, imageHeight;
let canvasRect = { left: 0, top: 0, width: 0, height: 0 };
let canvasScaleX = 1;
let canvasScaleY = 1;

// åˆå§‹åŒ–çŠ¶æ€ç®¡ç†
const StateManager = {
    saveState: () => {
        historyStack.push(JSON.parse(JSON.stringify(currentState)));
        UI.updateUndoButton();
    },
    
    restorePreviousState: () => {
        if (historyStack.length > 0) {
            currentState = historyStack.pop();
            UI.update();
        }
    },
    
    resetState: () => {
        historyStack = [];
        currentState = {
            calibrationPoints: { left: null, right: null },
            measurementPoints: {
                right: { pupil: null, frameBottom: null },
                left: { pupil: null, frameBottom: null }
            },
            scale: 0,
            currentEye: 'right',
            selectedMarker: null
        };
        UI.update();
    }
};

// æ›´æ–°ç”»å¸ƒä½ç½®å’Œç¼©æ”¾ä¿¡æ¯
function updateCanvasRect() {
    const rect = Elements.canvas.getBoundingClientRect();
    canvasRect.left = rect.left;
    canvasRect.top = rect.top;
    canvasRect.width = rect.width;
    canvasRect.height = rect.height;
    
    canvasScaleX = Elements.canvas.width / canvasRect.width;
    canvasScaleY = Elements.canvas.height / canvasRect.height;
}

// å°†è§¦æ‘¸äº‹ä»¶åæ ‡è½¬æ¢ä¸ºç”»å¸ƒå†…éƒ¨åæ ‡
function touchToCanvasCoordinates(touchX, touchY) {
    const x = touchX - canvasRect.left;
    const y = touchY - canvasRect.top;
    
    const canvasX = x * canvasScaleX;
    const canvasY = y * canvasScaleY;
    
    return { x: canvasX, y: canvasY };
}

// ç¼©æ”¾ç®¡ç†å™¨
const ZoomManager = {
    setZoom: (newZoom, centerX = null, centerY = null) => {
        newZoom = Math.max(0.1, Math.min(5, newZoom));
        
        if (centerX !== null && centerY !== null) {
            const worldX = (centerX - offsetX) / zoom;
            const worldY = (centerY - offsetY) / zoom;
            
            offsetX = centerX - worldX * newZoom;
            offsetY = centerY - worldY * newZoom;
        }
        
        zoom = newZoom;
        Elements.zoomLevel.textContent = Math.round(zoom * 100) + '%';
        
        Elements.dragHint.style.display = zoom > 1 ? 'block' : 'none';
        Elements.precisionHint.style.display = zoom > 1 ? 'block' : 'none';
        
        Marker.drawAll();
    },
    
    zoomIn: () => {
        ZoomManager.setZoom(zoom * 1.2, canvasRect.width / 2, canvasRect.height / 2);
    },
    
    zoomOut: () => {
        ZoomManager.setZoom(zoom / 1.2, canvasRect.width / 2, canvasRect.height / 2);
    },
    
    reset: () => {
        zoom = 1.0;
        offsetX = 0;
        offsetY = 0;
        Elements.zoomLevel.textContent = '100%';
        Elements.dragHint.style.display = 'none';
        Elements.precisionHint.style.display = 'none';
        Marker.drawAll();
    },
    
    screenToWorld: (screenX, screenY) => {
        return {
            x: (screenX - offsetX) / zoom,
            y: (screenY - offsetY) / zoom
        };
    },
    
    worldToScreen: (worldX, worldY) => {
        return {
            x: worldX * zoom + offsetX,
            y: worldY * zoom + offsetY
        };
    }
};

// ç”¨æˆ·ç•Œé¢ç®¡ç†
const UI = {
    update: () => {
        Elements.scaleResult.textContent = currentState.scale ? currentState.scale.toFixed(4) + ' mm/åƒç´ ' : '0 mm/åƒç´ ';
        
        if (currentState.scale) {
            Elements.singleValue.textContent = '--';
            Elements.finalResult.innerHTML = '';
        }
        
        Marker.drawAll();
        UI.updateStatus();
        UI.updateUndoButton();
    },
    
    updateStatus: () => {
        let status = '';
        if (!currentState.scale) {
            if (!currentState.calibrationPoints.left) {
                status = '1ï¼šç‚¹å‡»é•œæ¡†å·¦è¾¹ç¼˜è¿›è¡Œæ ‡å®š';
            } else if (!currentState.calibrationPoints.right) {
                status = '2ï¼šç‚¹å‡»é•œæ¡†å³è¾¹ç¼˜è¿›è¡Œæ ‡å®š';
            } else {
                status = '3ï¼šè¾“å…¥å®é™…é•œæ¡†å®½åº¦å¹¶ç‚¹å‡»"è®¡ç®—æ¯”ä¾‹"';
            }
        } else {
            const eyeData = currentState.measurementPoints[currentState.currentEye];
            
            if (!eyeData.pupil) {
                status = `4-${currentState.currentEye === 'right' ? '1' : '2'}ï¼šç‚¹å‡»${currentState.currentEye === 'right' ? 'å³' : 'å·¦'}çœ¼ç³å­”ä¸­å¿ƒ`;
            } else if (!eyeData.frameBottom) {
                status = `4-${currentState.currentEye === 'right' ? '2' : '3'}ï¼šç‚¹å‡»${currentState.currentEye === 'right' ? 'å³' : 'å·¦'}çœ¼é•œæ¡†ä¸‹ç¼˜`;
            } else {
                if (currentState.currentEye === 'right') {
                    currentState.currentEye = 'left';
                    status = '5-1ï¼šç‚¹å‡»å·¦çœ¼ç³å­”ä¸­å¿ƒ';
                } else {
                    status = 'âœ… æµ‹é‡å®Œæˆï¼ŒæŸ¥çœ‹ä¸‹æ–¹ç»“æœ';
                    Elements.measurementSection.style.display = 'block';
                }
            }
        }
        Elements.status.textContent = status;
    },
    
    updateUndoButton: () => {
        Elements.undoButton.disabled = historyStack.length === 0;
    }
};

// æ ‡è®°ç‚¹ç»˜åˆ¶ç®¡ç†
const Marker = {
    drawAll: () => {
        ctx.clearRect(0, 0, Elements.canvas.width, Elements.canvas.height);
        
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(zoom, zoom);
        
        if (img.complete && img.naturalWidth > 0) {
            ctx.drawImage(img, 0, 0, imageWidth, imageHeight);
        }
        
        Marker.drawCalibration('left', '#4a90e2');
        Marker.drawCalibration('right', '#4a90e2');
        Marker.drawPupil('right', '#7ed321');
        Marker.drawFrameBottom('right', '#7ed321');
        Marker.drawPupil('left', '#f5a623');
        Marker.drawFrameBottom('left', '#f5a623');
        
        ctx.restore();
    },
    
    drawCalibration: (side, color) => {
        const point = currentState.calibrationPoints[side];
        if (!point) return;
        
        const lineLength = 120 / zoom;
        ctx.beginPath();
        ctx.moveTo(point.x, point.y - lineLength/2);
        ctx.lineTo(point.x, point.y + lineLength/2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 8 / zoom;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(point.x, point.y, 8 / zoom, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        
        ctx.fillStyle = color;
        ctx.font = `${12 / zoom}px Arial`;
        ctx.fillText(side === 'left' ? 'å·¦åŸºå‡†' : 'å³åŸºå‡†', point.x + 6 / zoom, point.y - lineLength/2 - 4 / zoom);
    },
    
    drawPupil: (eye, color) => {
        const point = currentState.measurementPoints[eye].pupil;
        if (!point) return;
        
        ctx.beginPath();
        ctx.arc(point.x, point.y, 10 / zoom, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2 / zoom;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = `${12 / zoom}px Arial`;
        ctx.fillText(eye === 'right' ? 'å³ç³å­”' : 'å·¦ç³å­”', point.x + 10 / zoom, point.y + 4 / zoom);
    },
    
    drawFrameBottom: (eye, color) => {
        const point = currentState.measurementPoints[eye].frameBottom;
        if (!point) return;
        
        const lineLength = 120 / zoom;
        ctx.beginPath();
        ctx.moveTo(point.x - lineLength/2, point.y);
        ctx.lineTo(point.x + lineLength/2, point.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 8 / zoom;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(point.x, point.y, 10 / zoom, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2 / zoom;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = `${12 / zoom}px Arial`;
        ctx.fillText(eye === 'right' ? 'å³ä¸‹ç¼˜' : 'å·¦ä¸‹ç¼˜', point.x + 8 / zoom, point.y - 8 / zoom);
    },
    
    getMarkerAtPosition: (screenX, screenY) => {
        const tolerance = 15 / zoom;
        const worldPos = ZoomManager.screenToWorld(screenX, screenY);
        
        const markers = [
            { type: 'calibration', side: 'left', point: currentState.calibrationPoints.left },
            { type: 'calibration', side: 'right', point: currentState.calibrationPoints.right },
            { type: 'measurement', eye: 'right', part: 'pupil', point: currentState.measurementPoints.right.pupil },
            { type: 'measurement', eye: 'right', part: 'frameBottom', point: currentState.measurementPoints.right.frameBottom },
            { type: 'measurement', eye: 'left', part: 'pupil', point: currentState.measurementPoints.left.pupil },
            { type: 'measurement', eye: 'left', part: 'frameBottom', point: currentState.measurementPoints.left.frameBottom }
        ];
        
        for (const marker of markers) {
            if (marker.point) {
                const dx = Math.abs(marker.point.x - worldPos.x);
                const dy = Math.abs(marker.point.y - worldPos.y);
                if (dx < tolerance && dy < tolerance) {
                    return marker;
                }
            }
        }
        return null;
    }
};

// è®¡ç®—å™¨
const Calculator = {
    calculateScale: () => {
        const actualWidth = parseFloat(Elements.actualWidth.value);
        if (currentState.calibrationPoints.left && currentState.calibrationPoints.right && actualWidth > 0) {
            const pixelWidth = Math.abs(currentState.calibrationPoints.right.x - currentState.calibrationPoints.left.x);
            currentState.scale = actualWidth / pixelWidth;
            Elements.scaleResult.textContent = currentState.scale.toFixed(4) + ' mm/åƒç´ ';
            currentState.currentEye = 'right';
            UI.updateStatus();
        }
    },
    
    calculatePD: (eye) => {
        const eyeData = currentState.measurementPoints[eye];
        if (eyeData.pupil && eyeData.frameBottom && currentState.scale) {
            const distancePixels = Math.abs(eyeData.frameBottom.y - eyeData.pupil.y);
            const pd = distancePixels * currentState.scale;
            
            Calculator.checkComplete();
        }
    },
    
    checkComplete: () => {
        if (currentState.measurementPoints.left.pupil && currentState.measurementPoints.left.frameBottom &&
            currentState.measurementPoints.right.pupil && currentState.measurementPoints.right.frameBottom) {
            
            const rightPupilY = currentState.measurementPoints.right.pupil.y;
            const rightFrameBottomY = currentState.measurementPoints.right.frameBottom.y;
            const leftPupilY = currentState.measurementPoints.left.pupil.y;
            const leftFrameBottomY = currentState.measurementPoints.left.frameBottom.y;
            
            const rightPD = Math.abs(rightFrameBottomY - rightPupilY) * currentState.scale;
            const leftPD = Math.abs(leftFrameBottomY - leftPupilY) * currentState.scale;
            
            Elements.singleValue.textContent = `${rightPD.toFixed(2)} mm | ${leftPD.toFixed(2)} mm | ${Math.abs(leftPD - rightPD).toFixed(2)} mm`;
            
            Elements.finalResult.innerHTML = `
                <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                    <div style="background: rgba(255,255,255,0.2); padding: 10px; border-radius: 5px;">
                        å³çœ¼ç³é«˜ï¼š${rightPD.toFixed(2)} mm
                    </div>
                    <div style="background: rgba(255,255,255,0.2); padding: 10px; border-radius: 5px;">
                        å·¦çœ¼ç³é«˜ï¼š${leftPD.toFixed(2)} mm
                    </div>
                    <div style="background: rgba(255,255,255,0.2); padding: 10px; border-radius: 5px;">
                        å·®å€¼ï¼š${Math.abs(leftPD - rightPD).toFixed(2)} mm
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 0.9rem;">
                    æç¤ºï¼šç³é«˜å·®å€¼å°äº2mmå±äºæ­£å¸¸èŒƒå›´
                </div>
            `;
        }
    }
};

// äº‹ä»¶å¤„ç†å™¨
const EventHandlers = {
    handleImageUpload: (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
            img.onload = function() {
                imageWidth = img.width;
                imageHeight = img.height;
                Elements.canvas.width = imageWidth;
                Elements.canvas.height = imageHeight;
                
                updateCanvasRect();
                ZoomManager.reset();
                
                Elements.uploadArea.style.display = 'none';
                Elements.canvas.style.display = 'block';
                Elements.canvasOverlay.style.display = 'flex';
                
                Marker.drawAll();
                StateManager.resetState();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    handleCanvasClick: (e) => {
        e.preventDefault();
        updateCanvasRect();
        let clientX, clientY;
        
        if (e.type === 'touchstart') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        const canvasCoords = touchToCanvasCoordinates(clientX, clientY);
        
        if (isDragging && currentState.selectedMarker) return;
        
        StateManager.saveState();
        const worldPos = ZoomManager.screenToWorld(canvasCoords.x, canvasCoords.y);

        if (!currentState.scale) {
            EventHandlers.handleCalibrationClick(worldPos.x, worldPos.y);
        } else {
            EventHandlers.handleMeasurementClick(worldPos.x, worldPos.y);
        }
        Marker.drawAll();
        UI.updateStatus();
    },
    
    handleCalibrationClick: (x, y) => {
        if (!currentState.calibrationPoints.left) {
            currentState.calibrationPoints.left = { x, y };
        } else if (!currentState.calibrationPoints.right) {
            currentState.calibrationPoints.right = { x, y };
        }
    },
    
    handleMeasurementClick: (x, y) => {
        const eyeData = currentState.measurementPoints[currentState.currentEye];
        if (!eyeData.pupil) {
            eyeData.pupil = { x, y };
        } else if (!eyeData.frameBottom) {
            eyeData.frameBottom = { x, y };
            Calculator.calculatePD(currentState.currentEye);
            if(currentState.currentEye === 'right') {
                currentState.currentEye = 'left';
                UI.updateStatus();
            } else {
                UI.updateStatus();
            }
        }
    },
    
    handleDragStart: (e) => {
        e.preventDefault();
        updateCanvasRect();
        let clientX, clientY;
        
        if (e.type === 'touchstart') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        const canvasCoords = touchToCanvasCoordinates(clientX, clientY);
        
        const clickedMarker = Marker.getMarkerAtPosition(canvasCoords.x, canvasCoords.y);
        if (clickedMarker) {
            currentState.selectedMarker = clickedMarker;
            StateManager.saveState();
            // è®¾ç½®æ‹–æ‹½æ—¶çš„åˆå§‹åç§»é‡
            const worldPos = ZoomManager.screenToWorld(canvasCoords.x, canvasCoords.y);
            const marker = clickedMarker;
            if (marker.type === 'calibration') {
                const markerPoint = currentState.calibrationPoints[marker.side];
                clickedMarker.offsetX = worldPos.x - markerPoint.x;
                clickedMarker.offsetY = worldPos.y - markerPoint.y;
            } else if (marker.type === 'measurement') {
                const markerPoint = currentState.measurementPoints[marker.eye][marker.part];
                clickedMarker.offsetX = worldPos.x - markerPoint.x;
                clickedMarker.offsetY = worldPos.y - markerPoint.y;
            }
        } else {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            Elements.canvas.style.cursor = 'grabbing';
        }
    },
    
    handleDragMove: (e) => {
        e.preventDefault();
        if (!isDragging && !currentState.selectedMarker) return;
        
        let clientX, clientY;
        
        if (e.type === 'touchmove') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        if (currentState.selectedMarker) {
            updateCanvasRect();
            const canvasCoords = touchToCanvasCoordinates(clientX, clientY);
            const worldPos = ZoomManager.screenToWorld(canvasCoords.x, canvasCoords.y);
            
            const marker = currentState.selectedMarker;
            if (marker.type === 'calibration') {
                // è°ƒæ•´æ ‡è®°ç‚¹ä½ç½®ï¼Œå‡å»åˆå§‹åç§»é‡ä»¥ç¡®ä¿é¼ æ ‡ä¸æ ‡è®°ç‚¹ç²¾å‡†å¯¹åº”
                currentState.calibrationPoints[marker.side] = { 
                    x: worldPos.x - marker.offsetX, 
                    y: worldPos.y - marker.offsetY 
                };
            } else if (marker.type === 'measurement') {
                // è°ƒæ•´æ ‡è®°ç‚¹ä½ç½®ï¼Œå‡å»åˆå§‹åç§»é‡ä»¥ç¡®ä¿é¼ æ ‡ä¸æ ‡è®°ç‚¹ç²¾å‡†å¯¹åº”
                currentState.measurementPoints[marker.eye][marker.part] = { 
                    x: worldPos.x - marker.offsetX, 
                    y: worldPos.y - marker.offsetY 
                };
                Calculator.calculatePD(marker.eye);
            }
            
            Marker.drawAll();
        } else if (isDragging) {
            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            
            offsetX += deltaX;
            offsetY += deltaY;
            
            lastX = clientX;
            lastY = clientY;
            
            Marker.drawAll();
        }
    },
    
    handleDragEnd: (e) => {
        e.preventDefault();
        currentState.selectedMarker = null;
        isDragging = false;
        Elements.canvas.style.cursor = 'crosshair';
    },
    
    handleReupload: () => {
        Elements.uploadArea.style.display = 'flex';
        Elements.canvas.style.display = 'none';
        Elements.canvasOverlay.style.display = 'none';
        Elements.measurementSection.style.display = 'none';
        Elements.actualWidth.value = '';
        StateManager.resetState();
        UI.update();
    }
};

// åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
Elements.undoButton.addEventListener('click', StateManager.restorePreviousState);
Elements.imageUpload.addEventListener('change', EventHandlers.handleImageUpload);
Elements.uploadArea.addEventListener('click', () => Elements.imageUpload.click());
Elements.reuploadButton.addEventListener('click', EventHandlers.handleReupload);
Elements.calculateScale.addEventListener('click', () => {
    StateManager.saveState();
    Calculator.calculateScale();
});

// ç¼©æ”¾æŒ‰é’®äº‹ä»¶
Elements.zoomIn.addEventListener('click', ZoomManager.zoomIn);
Elements.zoomOut.addEventListener('click', ZoomManager.zoomOut);
Elements.resetZoom.addEventListener('click', ZoomManager.reset);

// ç”»å¸ƒäº‹ä»¶ - æ”¯æŒè§¦æ‘¸å’Œé¼ æ ‡
Elements.canvas.addEventListener('touchstart', EventHandlers.handleCanvasClick);
Elements.canvas.addEventListener('mousedown', EventHandlers.handleCanvasClick);

// æ‹–æ‹½åŠŸèƒ½ - æ”¯æŒè§¦æ‘¸å’Œé¼ æ ‡
Elements.canvas.addEventListener('touchstart', EventHandlers.handleDragStart);
Elements.canvas.addEventListener('mousemove', EventHandlers.handleDragMove);
Elements.canvas.addEventListener('touchmove', EventHandlers.handleDragMove);
Elements.canvas.addEventListener('mouseup', EventHandlers.handleDragEnd);
Elements.canvas.addEventListener('touchend', EventHandlers.handleDragEnd);
Elements.canvas.addEventListener('mouseleave', EventHandlers.handleDragEnd);

// çª—å£å¤§å°å˜åŒ–æ—¶æ›´æ–°ç”»å¸ƒä½ç½®
window.addEventListener('resize', () => {
    updateCanvasRect();
    Marker.drawAll();
});

// å…è®¸æ‹–æ‹½ä¸Šä¼ 
Elements.uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    Elements.uploadArea.style.borderColor = 'var(--primary-color)';
    Elements.uploadArea.style.backgroundColor = '#eef7ff';
});

Elements.uploadArea.addEventListener('dragleave', () => {
    Elements.uploadArea.style.borderColor = 'var(--border-color)';
    Elements.uploadArea.style.backgroundColor = '#f8f9fa';
});

Elements.uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    Elements.uploadArea.style.borderColor = 'var(--border-color)';
    Elements.uploadArea.style.backgroundColor = '#f8f9fa';
    
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
        Elements.imageUpload.files = e.dataTransfer.files;
        EventHandlers.handleImageUpload({target: {files: [file]}});
    }
});

// åˆå§‹åŒ–
UI.update();
</script>
</body>
</html>
